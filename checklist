ğŸ“Œ Estado atual do projeto (V-Sharp)
bash
Copiar
Editar
vsharp-lexer-parser/
â”œâ”€ Makefile               â†’ compila tudo no sub-diretÃ³rio build/
â”œâ”€ examples/              â†’ scripts de teste (.vs)
â”‚  â”œâ”€ sanity.vs           â†’ cobre aritmÃ©tica, arrays, print, while
â”‚  â””â”€ full.vs             â†’ cobre quase toda a EBNF (hoje falha em holders)
â”œâ”€ build/                 â†’ artefactos (criados pelo make)
â””â”€ src/
   â”œâ”€ vsharp.l            â†’ *lexer* 100 % da EBNF (tokens, datas, â€œ:â€ etc.)
   â”œâ”€ vsharp.y            â†’ *parser* â˜… falta suporte completo a:
   â”‚   Â· NODE_CALL (npv/irr/wacc, prints variÃ¡dicos jÃ¡ ok)
   â”‚   Â· if/while/for reais (gera NOP)
   â”‚   Â· blocos internos de entity/cap_table + lista de pairs
   â”œâ”€ ast.h / ast.c       â†’ AST heterogÃ©nea  
   â”‚   Â· âœ” NODE_ARRAY/NODE_PAIR, literais, print variÃ¡dico  
   â”‚   Â· â˜… falta NODE_CALL, NODE_IF, NODE_WHILE, NODE_FOR, blocos de domÃ­nio
   â”œâ”€ sem.h / sem.c       â†’ Analisador semÃ¢ntico  
   â”‚   Â· variÃ¡veis + tipos primitivos/array  
   â”‚   Â· â˜… nÃ£o valida pairs nem npv/irr/wacc nem domÃ­nio
   â”œâ”€ irgen.h / irgen.c   â†’ GeraÃ§Ã£o LLVM **mÃ­nima**  
   â”‚   Â· int/double, print, arrays (heap)  
   â”‚   Â· â˜… nÃ£o emite if/while, chamadas financeiras, strings globais param.
   â”œâ”€ runtime.c           â†’ `malloc`, `npv`, `irr`, `wacc`
   â””â”€ main.c              â†’ dirige parse â†’ sem â†’ ir â†’ `out.ll`
âœ… JÃ¡ implementado
Fase	Cobertura
LÃ©xico	100 % de tokens (ident, nÃºmero, string, date, â€œ:// â€¦â€)
Sintaxe	var/aritm., arrays, strings, print variÃ¡dico, comparaÃ§Ãµes, metric_call (ainda NOP)
AST	Literais primitivos, arrays heterogÃ©neos, pares "k":expr, print variÃ¡dico
SemÃ¢ntica	Tipos primÃ¡rios + promoÃ§Ã£o intâ†’float, escopos encadeados
Runtime	npv, irr, wacc, make_array
IR	Inteiros/doubles, prints, arrays â†’ heap

ğŸŸ¥ O que falta p/ versÃ£o final
Prioridade	Item	Onde mexer	ObservaÃ§Ã£o
â‘ 	Chamadas a funÃ§Ãµes npv/irr/wacc	ast.[hc] + vsharp.y â†’ NODE_CALL ; irgen.c gera call	valida nÂº/ tipo de args no sem.c
â‘¡	Fluxo de controlo if / while / for	ast.[hc] + vsharp.y â†’ NODE_IF, NODE_WHILE, NODE_FOR ; irgen.c emite labels/br	
â‘¢	Pairs no parser ("Alice": 5)	regra pair_list, token COLON jÃ¡ existe â€” basta ligar ao NODE_PAIR	semÃ¢ntica: string chave â‰  vazia
â‘£	Blocos de domÃ­nio (share_classes {â€¦})	gerar sub-Ã¡rvore (NODE_ENTITY, etc.) ou manter NOP mas aceitar pares aninhados	validaÃ§Ãµes cruzadas depois
â‘¤	Strings globais reais	irgen.c gerar @.strN em todos prints (jÃ¡ esboÃ§ado)	
â‘¥	VerificaÃ§Ã£o npv/irr/wacc	em sem.c checar aridade (2,1,4) e tipos float/array	
â‘¦	For completo	parse + irgen (contador, comparaÃ§Ã£o, incremento)	opcional para MVP

ğŸ—‚ï¸ AlteraÃ§Ã£o Ãºnica por arquivo (road-map)
Ordem	Arquivo	Alterar uma vez	ConteÃºdo a adicionar
1	ast.h / ast.c	â• NODE_CALL, NODE_IF, NODE_WHILE, NODE_FOR e respectivos campos (call, if_s, loop)	construtores: new_call(), new_if(), new_while()â€¦
2	vsharp.y	ligar:
â€¢ chamadas â†’ new_call()
â€¢ if/while/for reais (usam blocos)
â€¢ pair_list â†’ new_pair()
â€¢ remover NOPs correspondentes	manter precedÃªncia; atualizar %type
3	sem.c	(a) empilhar tabs nos novos blocos
(b) infer_expr trata NODE_CALL (retorna T_FLOAT)
(c) verifica pairs (key string, value vÃ¡lido)	erros â†’ error_cnt++
4	irgen.c	â€¢ caso NODE_CALL: declareÂ @npv/@irr/@wacc, faz promoÃ§Ã£o intâ†’double, passa array* / cont.
â€¢ emit_if, emit_while com labels
â€¢ imprime strings com %s tambÃ©m	arrays jÃ¡ prontos
5	runtime.c	nada (jÃ¡ ok)	
6	main.c	sÃ³ se quiser CLI para passar ficheiro; nÃ£o obrigatÃ³rio	
7	Makefile	jÃ¡ compila tudo â€” sem mudanÃ§as	

(mexendo uma Ãºnica vez em cada arquivo acima completamos a EBNF).

ğŸ Passo-a-passo atÃ© a â€œversÃ£o finalâ€
AST â€“ acrescentar novos tipos & construtores.

Parser â€“ gerar esses nÃ³s; remover NODE_NOPs.

SemÃ¢ntica â€“ validar:

variÃ¡veis, tipos, promoÃ§Ã£o;

calls npv/irr/wacc (2, 1, 4 args);

holders "str": num;

futuramente â€” coerÃªncia cap_table â†” entity.

IR â€“

strings globais %s;

call double @npv(double, double*, i32) etc.;

if/while com icmp + br;

arrays jÃ¡ funcionam (malloc, store).

Testes â€“ examples/full.vs deve:

compilar sem erros;

gerar out.ll que imprime resultado plausÃ­vel;

lli build/out.ll roda (se LLVM instalado).

Polimento â€“ mensagens, for/scope extra, docs no README.

Siga a tabela â€œAlteraÃ§Ã£o Ãºnica por arquivoâ€: depois de editar cada
fonte apenas uma vez, invoque make â” todos os scripts-exemplo
devem compilar e executar, concluindo a versÃ£o final do compilador